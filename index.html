<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cookie Clicker</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1724;
      --accent:#f6b042;
      --muted:#9aa7c7;
      --glass: rgba(255,255,255,0.03);
      --glass-2: rgba(255,255,255,0.02);
      --success: #7ee787;
      --danger:#ff6b6b;
      --card-radius:14px;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body { height:100%; margin:0; background:radial-gradient(1200px 600px at 10% 20%, rgba(255,180,60,0.03), transparent), var(--bg); color:#e6eef8; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    .app {
      max-width:1100px;
      margin:28px auto;
      display:grid;
      grid-template-columns: 420px 1fr;
      gap:18px;
      padding:18px;
    }

    /* Left column - cookie + stats */
    .left {
      background:linear-gradient(180deg,var(--panel), rgba(255,255,255,0.01));
      border-radius: var(--card-radius);
      padding:18px;
      box-shadow: 0 8px 30px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .cookie-wrap {
      display:flex;
      align-items:center;
      gap:18px;
    }
    .cookie {
      width:200px;
      height:200px;
      border-radius:50%;
      background: conic-gradient(from 120deg, #f7d08a, #f6b042 30%, #f6d37a 60%, #f0a84a 100%);
      box-shadow: inset -12px -10px 20px rgba(0,0,0,0.45), 0 20px 40px rgba(0,0,0,0.5);
      display:grid;
      place-items:center;
      position:relative;
      cursor:pointer;
      user-select:none;
      transition: transform 90ms cubic-bezier(.2,.9,.3,1);
    }
    .cookie:active { transform: scale(0.98) rotate(-2deg); }
    .cookie:focus { outline:4px solid rgba(246,176,66,0.12); }
    .chip {
      width:18px;height:18px;border-radius:50%;position:absolute;
      background:rgba(65,32,2,0.15);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.06);
    }
    /* place a few chips */
    .chip.c1{ left:20px; top:30px; transform:rotate(12deg) }
    .chip.c2{ right:28px; top:42px; transform:rotate(8deg) }
    .chip.c3{ left:46px; bottom:40px; transform: rotate(-10deg) }
    .chip.c4{ right:68px; bottom:56px; transform: rotate(22deg) }

    .stats {
      flex:1;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .big-numbers{ font-weight:700; font-size:20px; color: #fff; }
    .muted { color:var(--muted); font-size:13px; }
    .small { font-size:13px; color:#dfe9ff; opacity:0.9; }
    .meter {
      height:12px; border-radius:999px; background:var(--glass); overflow:hidden;
    }
    .meter > i{ display:block; height:100%; width:0%; background:linear-gradient(90deg,var(--accent), #ffd18a); transition:width .3s ease; }

    /* Right column - shop */
    .right {
      background:linear-gradient(180deg,var(--panel), rgba(255,255,255,0.01));
      border-radius: var(--card-radius);
      padding:14px;
      box-shadow: 0 8px 30px rgba(2,6,23,0.6);
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:420px;
    }
    .shop {
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(240px,1fr));
      gap:12px;
    }
    .upgrade {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      padding:12px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      border:1px solid rgba(255,255,255,0.02);
      transition: transform .12s ease, box-shadow .12s ease;
    }
    .upgrade:hover{ transform:translateY(-6px); box-shadow: 0 10px 30px rgba(2,6,23,0.5); }
    .u-icon {
      width:46px;height:46px;border-radius:10px; background:var(--glass-2); display:grid; place-items:center; font-weight:700;
      color:var(--accent); font-size:18px;
    }
    .u-body { flex:1; min-width:0; }
    .u-title { font-weight:700; font-size:14px; color:#fff }
    .u-desc { font-size:12px; color:var(--muted); margin-top:4px; }
    .u-line { display:flex; gap:6px; align-items:center; margin-top:8px; justify-content:space-between; }
    .btn {
      background: linear-gradient(180deg,#17324a, #0f2a40);
      border:1px solid rgba(255,255,255,0.03);
      color:#eaf6ff; padding:8px 10px; border-radius:8px; font-weight:700; cursor:pointer;
    }
    .btn:disabled { opacity:0.45; cursor:not-allowed; filter:grayscale(0.2); }

    .controls { display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .input-num { width:80px; background:transparent; color:#eaf6ff; border:1px solid rgba(255,255,255,0.03); padding:8px; border-radius:8px; text-align:center; }

    footer small { color:var(--muted); }

    /* responsive */
    @media (max-width:980px){
      .app{ grid-template-columns: 1fr; padding:12px; gap:12px; }
    }
    /* tooltip */
    .tooltip {
      position:relative;
    }
    .tooltip .tip {
      position:absolute; left:50%; transform:translateX(-50%); bottom:110%;
      background:#071226; color:var(--muted); padding:8px;border-radius:8px; font-size:12px; white-space:nowrap; display:none;
      box-shadow: 0 4px 18px rgba(0,0,0,0.6);
    }
    .tooltip:hover .tip { display:block; }
    /* animation for floating + pop */
    .floating {
      animation: floaty 3.6s ease-in-out infinite;
    }
    @keyframes floaty {
      0% { transform: translateY(0); }
      50% { transform: translateY(-6px); }
      100% { transform: translateY(0); }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Roof Cookies Clicker">
    <div class="left" aria-live="polite">
      <div class="cookie-wrap">
        <div id="cookie" class="cookie" role="button" tabindex="0" aria-label="Bake cookie by clicking or pressing space">
          <div class="chip c1"></div>
          <div class="chip c2"></div>
          <div class="chip c3"></div>
          <div class="chip c4"></div>
          <svg id="cookie-icon" width="80" height="80" viewBox="0 0 24 24" fill="none" class="floating" aria-hidden="true">
            <circle cx="12" cy="12" r="10" fill="none" stroke="rgba(255,255,255,0.06)" stroke-width="1.2"/>
            <g fill="#fef7eb">
              <circle cx="9.6" cy="10.6" r="1.2" opacity="0.85"/>
              <circle cx="14" cy="8.8" r="1.3" opacity="0.9"/>
              <circle cx="13" cy="14.2" r="1.05" opacity="0.8"/>
            </g>
          </svg>
        </div>

        <div class="stats">
          <div style="display:flex;justify-content:space-between;align-items:end">
            <div>
              <div class="big-numbers" id="cookie-count" aria-live="assertive">0</div>
              <div class="muted">Total Roof Cookies</div>
            </div>
            <div style="text-align:right">
              <div class="small muted">Clicks: <span id="clicks">0</span></div>
              <div class="small muted">Playtime: <span id="playtime">0s</span></div>
            </div>
          </div>

          <div>
            <div class="muted">Cookies Per Second <span id="cps" class="small" style="margin-left:8px">0</span></div>
            <div class="meter" aria-hidden="true" style="margin-top:6px"><i id="meterbar"></i></div>
          </div>

          <div style="display:flex;gap:8px;align-items:center;justify-content:space-between;">
            <div class="muted">Cookies Per Click: <strong id="cpc">1</strong></div>
            <div style="display:flex;gap:8px;">
              <button id="export" class="btn" title="Export save">Export</button>
              <button id="import" class="btn" title="Import save">Import</button>
            </div>
          </div>

          <div style="display:flex;gap:8px;align-items:center;justify-content:space-between;">
            <div class="muted">Auto-save: <span id="autosave-status">On</span></div>
            <div class="muted">Save slot: <span id="save-date">—</span></div>
          </div>
        </div>
      </div>

      <div style="display:flex;gap:10px;align-items:center;justify-content:space-between;margin-top:6px">
        <div class="controls" style="gap:10px;">
          <label for="buy-amount" class="muted">Buy amount</label>
          <select id="buy-amount" class="input-num" title="Choose how many of an upgrade to buy">
            <option value="1">1</option>
            <option value="5">5</option>
            <option value="10">10</option>
            <option value="max">Max</option>
          </select>
        </div>

        <div style="display:flex;gap:8px;">
          <button id="reset" class="btn" title="Reset game">Reset</button>
          <button id="bulk" class="btn" title="Buy the most affordable upgrades automatically">Buy Best</button>
        </div>
      </div>

      <footer style="margin-top:12px; display:flex;justify-content:space-between;align-items:center;">
        <small>Advanced version • 20 upgrades • Made by James Degenhardt</small>
        <small>Press <strong>Space</strong> to click</small>
      </footer>
    </div>

    <div class="right">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <h3 style="margin:0">Upgrade Shop</h3>
        <div class="muted small">Hover an upgrade for details</div>
      </div>

      <div id="shop" class="shop" aria-live="polite"></div>

      <div style="margin-top:auto; display:flex;gap:8px; align-items:center; justify-content:space-between;">
        <div class="muted small">Tip: Use keyboard numbers 1–9 to buy an upgrade in that slot</div>
        <div>
          <button id="toggle-sound" class="btn">Sound: On</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  /* Advanced Cookie Clicker
     Single-file HTML app.
     - 20 upgrades
     - Each upgrade gives cps and cpc boost
     - Cost scales
     - localStorage saves
  */

  // ---------- Configuration ----------
  const SAVE_KEY = 'roof-cookies-save-v1';
  const AUTO_SAVE_INTERVAL = 5000; // ms
  const TICK_INTERVAL = 100; // ms: how often we apply CPS (per 100ms) for smoother increments

  // Define 20 upgrades. Each has: id, name, baseCost, costMultiplier, baseCps, baseCpc, description
  // Costs and power are balanced across a curve; you can tweak these values to tune gameplay.
  const UPGRADE_DEFS = Array.from({length:20}, (_,i)=>{
    const id = i+1;
    // cost curve: start low, grow exponentially
    const baseCost = Math.round(10 * Math.pow(2.75, i)); // escalates quickly over 20 items
    // Each upgrade provides some cps and cpc. Later upgrades give more.
    const baseCps = +(Math.pow(1.6, i) * 0.02).toFixed(3); // small base, scales
    const baseCpc = +(Math.pow(1.5, i) * 0.05).toFixed(3);
    return {
      id,
      key: 'up'+id,
      name: ['Tiny Oven','Worker Bee','Roofsitter','Street Baker','Solar Oven','Cookie Mill','Factory','Conveyor Array','Automated Baker','AI Baker','Quantum Oven','Grav-Crumb','Dark-Fermenter','Holo-Kitchen','Meteor Oven','Antimatter Kiln','Dimensional Oven','Omega Brewer','Chrono Crisper','Singularity Forge'][i],
      baseCost,
      costMultiplier: 1.15 + i*0.02, // slight increase in multiplier for later items
      baseCps,
      baseCpc,
      description: `Grants +${baseCps} CPS and +${baseCpc} CPC per unit.`,
    };
  });

  // ---------- Game State ----------
  const state = {
    cookies: 0,
    totalCookies: 0,
    clicks: 0,
    cps: 0,
    cpc: 1,
    playSeconds: 0,
    upgrades: {}, // key -> {amount, effectiveCost}
    lastTick: Date.now(),
    lastSave: null,
    sound: true,
  };

  // initialize upgrades state
  UPGRADE_DEFS.forEach(u => state.upgrades[u.key] = { amount: 0, nextCost: u.baseCost });

  // ---------- DOM refs ----------
  const $cookie = document.getElementById('cookie');
  const $cookieCount = document.getElementById('cookie-count');
  const $cps = document.getElementById('cps');
  const $cpc = document.getElementById('cpc');
  const $shop = document.getElementById('shop');
  const $buyAmt = document.getElementById('buy-amount');
  const $clicks = document.getElementById('clicks');
  const $playtime = document.getElementById('playtime');
  const $meterBar = document.getElementById('meterbar');
  const $autosaveStatus = document.getElementById('autosave-status');
  const $saveDate = document.getElementById('save-date');
  const $export = document.getElementById('export');
  const $import = document.getElementById('import');
  const $reset = document.getElementById('reset');
  const $bulk = document.getElementById('bulk');
  const $toggleSound = document.getElementById('toggle-sound');

  // audio context + click sound
  let audioCtx = null;
  function initAudio(){
    if(audioCtx) return;
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch(e){}
  }
  function playClickSound(){
    if(!state.sound) return;
    initAudio();
    if(!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.value = 520 + Math.random()*80;
    g.gain.value = 0.02;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.frequency.exponentialRampToValueAtTime(900, audioCtx.currentTime + 0.05);
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.12);
    o.stop(audioCtx.currentTime + 0.13);
  }

  // ---------- Utility functions ----------
  function fmt(n){
    // friendly formatting with suffixes
    if(n < 1000) return Math.round(n*100)/100;
    const units = ['k','M','B','T','Q'];
    let u = -1;
    while(n >= 1000 && u < units.length-1){ n /= 1000; u++; }
    return (Math.round(n*100)/100) + units[u];
  }

  function now(){ return Date.now(); }

  // compute cost for next N of an upgrade (geometric series)
  function costForBuy(upDef, owned, n){
    // cost_n = base * multiplier^(owned) * (mult^(n)-1) / (mult-1)
    const m = upDef.costMultiplier;
    const base = upDef.baseCost;
    const start = base * Math.pow(m, owned);
    if(n === 'max') {
      // we won't compute here; calling code will attempt to buy as many as possible given current cookies
      return null;
    }
    const total = start * (Math.pow(m, n) - 1) / (m - 1);
    return Math.ceil(total);
  }

  function updateDerivedStats(){
    // recompute cps and cpc from upgrades
    let cps = 0;
    let cpc = 1; // base click = 1
    for(const u of UPGRADE_DEFS){
      const amt = state.upgrades[u.key].amount;
      cps += amt * u.baseCps;
      cpc += amt * u.baseCpc;
    }
    state.cps = +cps.toFixed(4);
    state.cpc = +cpc.toFixed(4);
  }

  // ---------- Shop UI ----------
  function buildShop(){
    $shop.innerHTML = '';
    UPGRADE_DEFS.forEach((u, idx) => {
      const s = state.upgrades[u.key];
      const card = document.createElement('div');
      card.className = 'upgrade tooltip';
      card.innerHTML = `
        <div class="u-icon" aria-hidden="true">${u.id}</div>
        <div class="u-body">
          <div class="u-title">${u.name} <span style="font-weight:600;color:var(--muted);font-size:12px"> x${s.amount}</span></div>
          <div class="u-desc">${u.description}</div>
          <div class="u-line">
            <div class="muted small">Cost: <strong id="cost-${u.key}">${fmt(s.nextCost)}</strong></div>
            <div>
              <button class="btn buy-btn" data-key="${u.key}" data-idx="${idx}" id="buy-${u.key}">Buy</button>
            </div>
          </div>
          <div class="tip small" id="tip-${u.key}">Base CPS: ${u.baseCps} • Base CPC: ${u.baseCpc} • Mult: ${u.costMultiplier.toFixed(2)}</div>
        </div>
      `;
      $shop.appendChild(card);
    });
    attachBuyHandlers();
  }

  function attachBuyHandlers(){
    document.querySelectorAll('.buy-btn').forEach(btn => {
      btn.onclick = () => {
        const key = btn.dataset.key;
        buyUpgrade(key);
      };
    });
  }

  // Buy logic (supports buy amount & max)
  function buyUpgrade(key){
    const upDef = UPGRADE_DEFS.find(u=>u.key===key);
    const slot = state.upgrades[key];
    const buyVal = $buyAmt.value; // '1', '5', '10', 'max'
    let amountToBuy = buyVal === 'max' ? 'max' : parseInt(buyVal,10);

    if(buyVal === 'max'){
      // greedy buy as many as possible
      let bought = 0;
      while(true){
        const cost = Math.ceil(upDef.baseCost * Math.pow(upDef.costMultiplier, slot.amount));
        if(cost <= state.cookies){
          state.cookies -= cost;
          slot.amount += 1;
          bought++;
        } else break;
      }
      if(bought > 0){
        afterPurchase(upDef);
      } else {
        flashButton(`#buy-${key}`, true);
      }
      return;
    }

    // compute total cost for amountToBuy
    const totalCost = costForBuy(upDef, slot.amount, amountToBuy);
    if(totalCost <= state.cookies){
      // apply purchase
      state.cookies -= totalCost;
      // increment amountToBuy times and update nextCost
      slot.amount += amountToBuy;
      slot.nextCost = Math.ceil(upDef.baseCost * Math.pow(upDef.costMultiplier, slot.amount));
      afterPurchase(upDef);
    } else {
      // not enough cookies: attempt to buy fewer if possible (smart buy)
      let affordable = 0;
      for(let n=1;n<=amountToBuy;n++){
        const c = costForBuy(upDef, slot.amount, n);
        if(c <= state.cookies) affordable = n;
        else break;
      }
      if(affordable > 0){
        const c = costForBuy(upDef, slot.amount, affordable);
        state.cookies -= c;
        slot.amount += affordable;
        slot.nextCost = Math.ceil(upDef.baseCost * Math.pow(upDef.costMultiplier, slot.amount));
        afterPurchase(upDef);
      } else {
        flashButton(`#buy-${key}`, true);
      }
    }
  }

  function afterPurchase(upDef){
    updateDerivedStats();
    render();
    // small particle/pop
    popCookie();
  }

  function flashButton(selector, danger=false){
    const el = document.querySelector(selector);
    if(!el) return;
    const origBg = el.style.boxShadow;
    el.style.boxShadow = danger ? '0 0 10px rgba(255,90,90,0.6)' : '0 0 10px rgba(255,200,90,0.8)';
    setTimeout(()=> el.style.boxShadow = origBg, 350);
  }

  // ---------- Click handling ----------
  function handleBake(mult=1){
    const gained = state.cpc * mult;
    state.cookies += gained;
    state.totalCookies += gained;
    state.clicks += 1;
    // small animation
    animateClick();
    playClickSound();
    updateDerivedStats();
    render();
  }

  // cookie pop animation
  function animateClick(){
    $cookie.animate([
      { transform: 'scale(1)' },
      { transform: 'scale(1.08) rotate(-6deg)' },
      { transform: 'scale(1)' }
    ], { duration: 200, easing:'cubic-bezier(.2,.9,.3,1)'});
  }

  function popCookie(){
    // quick "shine" overlay, simple CSS-in-JS
    const el = document.createElement('div');
    el.style.position='absolute';
    el.style.pointerEvents='none';
    el.style.width='60px';
    el.style.height='60px';
    el.style.right='18px';
    el.style.top='18px';
    el.style.borderRadius='50%';
    el.style.background='radial-gradient(circle, rgba(255,255,255,0.6), rgba(255,255,255,0))';
    el.style.opacity='0.9';
    el.style.transform='scale(0.2)';
    $cookie.appendChild(el);
    el.animate([
      { transform:'scale(0.2)', opacity:1 },
      { transform:'scale(1.8)', opacity:0 }
    ], { duration: 420 }).finished.then(()=> el.remove());
  }

  // ---------- Game loop ----------
  let tickAccumulator = 0;
  function tick(deltaMs){
    // apply cookies from CPS smoothly at TICK_INTERVAL
    const perMs = state.cps / 1000;
    state.cookies += perMs * deltaMs;
    state.totalCookies += perMs * deltaMs;
    tickAccumulator += deltaMs;
    if(tickAccumulator >= 1000){
      state.playSeconds += Math.floor(tickAccumulator/1000);
      tickAccumulator = tickAccumulator % 1000;
    }
  }

  // rendering function
  function render(){
    // clamp small floating point inaccuracies
    if(state.cookies < 0) state.cookies = 0;
    $cookieCount.textContent = fmt(state.cookies);
    $cps.textContent = `${fmt(state.cps)} cps`;
    $cpc.textContent = fmt(state.cpc);
    $clicks.textContent = state.clicks;
    $playtime.textContent = state.playSeconds + 's';

    // update shop costs + amounts
    UPGRADE_DEFS.forEach(u=>{
      const slot = state.upgrades[u.key];
      const costEl = document.getElementById(`cost-${u.key}`);
      if(costEl) costEl.textContent = fmt(Math.ceil(u.baseCost * Math.pow(u.costMultiplier, slot.amount)));
      const buyBtn = document.getElementById(`buy-${u.key}`);
      if(buyBtn){
        const cost = Math.ceil(u.baseCost * Math.pow(u.costMultiplier, slot.amount));
        buyBtn.disabled = (cost > state.cookies);
      }
      // update title with amount
      const titleEl = document.querySelector(`#buy-${u.key}`) ? document.querySelector(`#buy-${u.key}`).closest('.u-body').querySelector('.u-title') : null;
      if(titleEl) titleEl.innerHTML = `${u.name} <span style="font-weight:600;color:var(--muted);font-size:12px"> x${slot.amount}</span>`;
    });

    // meter bar just represents (cps normalized to a reasonable scale)
    const scaled = Math.min(100, Math.log10(1 + state.cps) * 18);
    $meterBar.style.width = `${scaled}%`;

    // save metadata
    $saveDate.textContent = state.lastSave ? new Date(state.lastSave).toLocaleString() : 'No save';
  }

  // start the main animation loop using requestAnimationFrame
  let lastFrame = now();
  function mainLoop(){
    const current = now();
    const delta = current - lastFrame;
    lastFrame = current;
    tick(delta);
    render();
    requestAnimationFrame(mainLoop);
  }

  // ---------- Save / Load ----------
  function saveGame(){
    const payload = {
      cookies: state.cookies,
      totalCookies: state.totalCookies,
      clicks: state.clicks,
      playSeconds: state.playSeconds,
      upgrades: {},
      lastSave: Date.now(),
      sound: state.sound
    };
    for(const k in state.upgrades){
      payload.upgrades[k] = { amount: state.upgrades[k].amount };
    }
    try {
      localStorage.setItem(SAVE_KEY, JSON.stringify(payload));
      state.lastSave = payload.lastSave;
      $autosaveStatus.textContent = 'On';
      render();
    } catch(e){
      console.warn('save failed', e);
      $autosaveStatus.textContent = 'Error';
    }
  }

  function loadGame(){
    try {
      const raw = localStorage.getItem(SAVE_KEY);
      if(!raw) return false;
      const data = JSON.parse(raw);
      state.cookies = data.cookies || 0;
      state.totalCookies = data.totalCookies || 0;
      state.clicks = data.clicks || 0;
      state.playSeconds = data.playSeconds || 0;
      for(const k in state.upgrades) state.upgrades[k].amount = (data.upgrades && data.upgrades[k] && data.upgrades[k].amount) || 0;
      state.sound = typeof data.sound === 'boolean' ? data.sound : true;
      state.lastSave = data.lastSave || Date.now();
      updateDerivedStats();
      render();
      return true;
    } catch(e){
      console.warn('load failed', e);
      return false;
    }
  }

  // export / import
  $export.onclick = () => {
    const raw = localStorage.getItem(SAVE_KEY);
    if(!raw) return alert('No save to export.');
    // copy to clipboard
    navigator.clipboard?.writeText(raw).then(()=> alert('Save exported to clipboard.'), ()=> prompt('Copy this save string:', raw));
  };
  $import.onclick = () => {
    const inStr = prompt('Paste save string to import:');
    if(!inStr) return;
    try {
      const data = JSON.parse(inStr);
      localStorage.setItem(SAVE_KEY, JSON.stringify(data));
      loadGame();
      alert('Save imported.');
    } catch(e){
      alert('Invalid save string.');
    }
  };

  // reset
  $reset.onclick = () => {
    if(!confirm('Reset the game? This will clear your local save.')) return;
    localStorage.removeItem(SAVE_KEY);
    // reset state
    state.cookies = 0; state.totalCookies = 0; state.clicks = 0; state.cps = 0; state.cpc = 1; state.playSeconds = 0; state.lastSave = null;
    UPGRADE_DEFS.forEach(u => state.upgrades[u.key] = { amount: 0, nextCost: u.baseCost });
    updateDerivedStats();
    render();
  };

  // buy best (simple greedy: buy cheapest affordable upgrade until can't)
  $bulk.onclick = () => {
    let loop = 0;
    while(loop < 200){
      // find cheapest upgrade cost that is <= cookies
      const affordable = UPGRADE_DEFS.map(u => {
        const amt = state.upgrades[u.key].amount;
        return { u, cost: Math.ceil(u.baseCost * Math.pow(u.costMultiplier, amt)) };
      }).filter(x=>x.cost <= state.cookies);
      if(affordable.length === 0) break;
      // pick best by cost-efficiency (cps+scaled cpc)/cost
      affordable.sort((a,b) => {
        const aGain = a.u.baseCps + a.u.baseCpc*0.5;
        const bGain = b.u.baseCps + b.u.baseCpc*0.5;
        return (bGain / b.cost) - (aGain / a.cost);
      });
      buyUpgrade(affordable[0].u.key);
      loop++;
    }
  };

  // toggle sound
  $toggleSound.onclick = () => {
    state.sound = !state.sound;
    $toggleSound.textContent = 'Sound: ' + (state.sound ? 'On' : 'Off');
    $toggleSound.style.opacity = state.sound ? '1' : '0.6';
  };

  // ---------- Input events ----------
  $cookie.onclick = () => handleBake(1);
  $cookie.onkeydown = (e) => {
    if(e.code === 'Space' || e.key === ' '){ e.preventDefault(); handleBake(1); }
  };
  // keyboard shortcuts: numbers 1..9 to buy shop slot
  document.addEventListener('keydown', (e)=>{
    if(document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT' || document.activeElement.isContentEditable)) return;
    if(e.key >= '1' && e.key <= '9'){
      const idx = parseInt(e.key,10) - 1;
      if(UPGRADE_DEFS[idx]) buyUpgrade(UPGRADE_DEFS[idx].key);
    }
    // space to click (if not used)
    if(e.code === 'Space' && e.target === document.body){
      e.preventDefault();
      handleBake(1);
    }
  });

  // ---------- Init ----------
  // build shop in DOM
  buildShop();
  // try load
  loadGame();
  updateDerivedStats();
  render();

  // autosave loop
  setInterval(()=> {
    saveGame();
    $autosaveStatus.textContent = 'On';
  }, AUTO_SAVE_INTERVAL);

  // main loop start
  requestAnimationFrame(mainLoop);

  // expose save to console (for debugging/tweaks)
  window.RoofCookies = { state, UPGRADE_DEFS, saveGame, loadGame, buyUpgrade, fmt };

  // friendly UI hint
  console.log('Roof Cookies initialized. Expose: RoofCookies');

  </script>
</body>
</html>
